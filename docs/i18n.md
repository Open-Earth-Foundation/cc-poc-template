# Internationalization (i18n) Setup

This template includes a complete internationalization setup using industry-standard libraries. This documentation explains how to use and extend the i18n system for your own projects.

## Overview & Architecture

### Stack
- **i18next**: Core i18n library with powerful features
- **react-i18next**: React hooks and components for i18next
- **i18next-browser-languagedetector**: Automatic language detection and persistence

### Why This Stack?
- Mature ecosystem with extensive documentation
- React hooks API for easy component integration
- Automatic language detection from browser/localStorage
- Built-in interpolation and pluralization support
- TypeScript-friendly

### Initialization
The i18n system is initialized in `client/src/lib/i18n.ts` and imported during app startup.

## File Structure

```
client/src/
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ i18n.ts                           # i18n configuration
‚îú‚îÄ‚îÄ locales/
‚îÇ   ‚îú‚îÄ‚îÄ en.json                          # English translations
‚îÇ   ‚îî‚îÄ‚îÄ pt.json                          # Portuguese translations
‚îî‚îÄ‚îÄ core/components/i18n/
    ‚îî‚îÄ‚îÄ language-switcher.tsx            # Language selection component
```

## Translation Key Organization

Translation keys are organized by feature domain for maintainability:

```json
{
  "login": { "title": "Login", ... },
  "citySelection": { "title": "Select City", ... },
  "header": { "title": "CC POC Module", ... },
  "navigation": { "logout": "Logout", ... },
  "boundaries": { "title": "City Boundaries", ... },
  "cityInfo": { "title": "City Information", ... },
  "user": { "profile": "User Profile", ... },
  "common": { "loading": "Loading...", ... },
  "errors": { "generic": "Something went wrong", ... },
  "modals": { "confirm": "Confirm", ... }
}
```

### Key Naming Conventions
- Use **lowerCamelCase** for keys: `cityInfo.dataOverview`
- Group by feature domain: `login.*`, `citySelection.*`
- Avoid concatenating strings at runtime
- Prefer full sentences with placeholders: `"Welcome {{name}}!"`

## Adding a New Language

### 1. Create Translation File
Create `client/src/locales/es.json` by copying `en.json` and translating all values:

```json
{
  "login": {
    "title": "Iniciar Sesi√≥n",
    "subtitle": "Conectar con CityCatalyst"
  }
}
```

### 2. Update Configuration
In `client/src/lib/i18n.ts`:

```typescript
// Add import
import esTranslations from '../locales/es.json';

// Update supported languages
supportedLngs: ['en', 'pt', 'es'],

// Add to resources
resources: {
  en: { translation: enTranslations },
  pt: { translation: ptTranslations },
  es: { translation: esTranslations },
}
```

### 3. Update Language Switcher
In `client/src/core/components/i18n/language-switcher.tsx`:

```typescript
const languages = [
  { code: 'en', name: 'EN', flag: 'üá∫üá∏' },
  { code: 'pt', name: 'PT', flag: 'üáßüá∑' },
  { code: 'es', name: 'ES', flag: 'üá™üá∏' },
];
```

### 4. Test
- Switch languages in UI
- Verify localStorage key `i18nextLng` updates
- Ensure fallback works when keys are missing

## Adding New Translation Keys

### 1. Add to Source (English)
First, add the key to `client/src/locales/en.json`:

```json
{
  "cityInfo": {
    "newFeature": "This is a new feature",
    "itemCount": "Found {{count}} items"
  }
}
```

### 2. Mirror in All Locales
Add the same key structure to all other locale files (`pt.json`, etc.):

```json
{
  "cityInfo": {
    "newFeature": "Esta √© uma nova funcionalidade",
    "itemCount": "Encontrados {{count}} itens"
  }
}
```

### 3. Use in Components
```typescript
import { useTranslation } from 'react-i18next';

export function MyComponent() {
  const { t } = useTranslation();
  const itemCount = 42;

  return (
    <div>
      <h2>{t('cityInfo.newFeature')}</h2>
      <p>{t('cityInfo.itemCount', { count: itemCount })}</p>
    </div>
  );
}
```

## Component Integration Patterns

### Basic Usage
```typescript
import { useTranslation } from 'react-i18next';

export function MyComponent() {
  const { t } = useTranslation();
  
  return (
    <button>{t('common.save')}</button>
  );
}
```

### With Interpolation
```typescript
const { t } = useTranslation();
const userName = "John";

return <p>{t('user.welcome', { name: userName })}</p>;
// Renders: "Welcome John!" (en) or "Bem-vindo John!" (pt)
```

### Accessibility Attributes
```typescript
<img 
  src="/icon.png" 
  alt={t('header.iconAlt')}
  aria-label={t('header.logoLabel')}
/>

<input 
  placeholder={t('common.searchPlaceholder')}
  aria-describedby="search-help"
/>
```

### Form Labels and Validation
```typescript
<Label htmlFor="email">{t('login.emailLabel')}</Label>
<Input 
  id="email"
  placeholder={t('login.emailPlaceholder')}
/>
{errors.email && (
  <span className="error">{t('errors.invalidEmail')}</span>
)}
```

## Configuration Details

### Language Detection
The system automatically detects user language from:
1. **localStorage** (`i18nextLng` key)
2. **navigator** (browser language)
3. **htmlTag** (`<html lang="...">`)
4. **path** (URL path like `/en/page`)
5. **subdomain** (`en.example.com`)

### Persistence
Selected language is automatically saved to localStorage and restored on app load.

### Debug Mode
For development, enable debug logging in `client/src/lib/i18n.ts`:

```typescript
i18n.use(initReactI18next).init({
  debug: true, // Enable during development
  // ... other config
});
```

This will log missing keys and other helpful information to the console.

### HTML Lang Sync (Recommended)
Add this to your main App component for better accessibility and SEO:

```typescript
import { useEffect } from 'react';
import { useTranslation } from 'react-i18next';

export function App() {
  const { i18n } = useTranslation();
  
  useEffect(() => {
    document.documentElement.lang = i18n.language;
  }, [i18n.language]);

  // ... rest of component
}
```

## Best Practices & Conventions

### Translation Keys
- ‚úÖ Keep English as the source of truth
- ‚úÖ Use descriptive, hierarchical keys: `cityInfo.dataOverview`
- ‚úÖ Prefer full sentences: `"Are you sure you want to delete?"`
- ‚ùå Avoid building strings at runtime: `t('hello') + ' ' + t('world')`

### Pluralization
For count-sensitive text, use i18next pluralization:

```json
{
  "cityInfo": {
    "itemCount_one": "{{count}} item found",
    "itemCount_other": "{{count}} items found"
  }
}
```

```typescript
// Usage
t('cityInfo.itemCount', { count: itemCount })
```

### Code Reviews
When adding translations:
- ‚úÖ Ensure all supported languages are updated
- ‚úÖ Test language switching functionality  
- ‚úÖ Search for hardcoded strings before committing
- ‚úÖ Verify interpolation variables match across languages

### Performance
- Translation files are loaded at build time (no runtime fetching)
- Only active language is kept in memory
- Switching languages is instant (no network requests)

## Troubleshooting

### Missing Translation Keys
- Check browser console with `debug: true`
- Verify key exists in all locale files
- Ensure proper nesting structure

### Language Not Switching
- Check localStorage for `i18nextLng` value
- Verify language is in `supportedLngs` array
- Ensure language switcher calls `i18n.changeLanguage()`

### Interpolation Not Working
- Verify placeholder syntax: `{{variableName}}`
- Check that variables are passed to `t()` function
- Ensure `interpolation.escapeValue: false` in config

## Contributing Guidelines

When working with translations:

1. **Always update all languages** when adding new keys
2. **Never delete translation keys** without searching for usage
3. **Keep placeholders consistent** across all languages
4. **Test language switching** after changes
5. **Use descriptive commit messages** for translation updates

## Example Implementation

See these files for complete examples:
- `client/src/core/pages/login.tsx` - Form translations
- `client/src/core/components/layout/header.tsx` - Navigation translations  
- `client/src/modules/city-information/pages/city-information.tsx` - Data display translations
- `client/src/core/components/i18n/language-switcher.tsx` - Language selection UI

This i18n setup provides a solid foundation for multilingual applications. The modular structure makes it easy to add new languages and maintain translations as your application grows.