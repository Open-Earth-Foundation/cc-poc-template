You’re getting a full Next.js HTML page back for GET https://citycatalyst.openearth.dev/api/v0/auth/me, which means you’re hitting a frontend route, not a JSON API route. That’s why your parser explodes on <!DOCTYPE html…> and why the headers look like:

content-type: text/html

x-nextjs-cache: HIT, x-nextjs-prerender: 1

the HTML even shows a “404 / not_found” page

So the issue isn’t your token—your URL/path is wrong (or not implemented) on that host.

Here’s how to fix it cleanly:

1) Use the right endpoint (or decode the ID token)

Many backends expose profile at /api/v0/users/me (or /user/me) rather than /auth/me. Try these with and without a trailing slash:

/api/v0/users/me

/api/v0/user/me

If the API doesn’t provide a me endpoint, use the OIDC id_token you got from the token exchange and decode it locally to get the user’s sub, email, name, etc. That avoids any “me” call entirely.

2) Make sure you’re calling the API host, not the UI host

Stick to the same base you used for token exchange (which worked):
https://citycatalyst.openearth.dev (avoid .org or the marketing site). If you ever see Next.js headers, you’ve hit the UI.

3) Send proper headers and handle non-JSON defensively

Send:

Authorization: Bearer <access_token>

Accept: application/json

And before res.json(), check content-type to guard against HTML:

async function fetchJSON(url: string, accessToken: string) {
  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "application/json",
    },
  });

  const ct = res.headers.get("content-type") || "";
  const text = await res.text(); // read once

  if (!ct.includes("application/json")) {
    throw new Error(
      `Expected JSON from ${url} but got ${ct}. This likely hit the UI (HTML) or a wrong path.\n` +
      `First 300 chars:\n${text.slice(0, 300)}`
    );
  }
  return JSON.parse(text);
}

4) Robust “get profile” helper (tries known paths, falls back to ID token)
type Tokens = {
  access_token: string;
  id_token?: string;
  token_type?: string;
  expires_in?: number;
};

function decodeJwt<T = any>(jwt: string): T | undefined {
  try {
    const [, payload] = jwt.split(".");
    // add padding for atob
    const pad = (s: string) => s + "=".repeat((4 - (s.length % 4)) % 4);
    return JSON.parse(Buffer.from(pad(payload).replace(/-/g, "+").replace(/_/g, "/"), "base64").toString("utf8"));
  } catch { return undefined; }
}

async function getUserProfileFromAPI(tokens: Tokens) {
  const base = "https://citycatalyst.openearth.dev";
  const candidates = [
    `${base}/api/v0/users/me`,
    `${base}/api/v0/users/me/`,
    `${base}/api/v0/user/me`,
    `${base}/api/v0/user/me/`,
  ];

  for (const url of candidates) {
    try {
      const data = await fetchJSON(url, tokens.access_token);
      return { source: url, profile: data };
    } catch (e) {
      // keep trying next
    }
  }

  // Fallback: decode id_token if present
  if (tokens.id_token) {
    const claims = decodeJwt(tokens.id_token) || {};
    return { source: "id_token", profile: {
      sub: claims.sub,
      email: claims.email,
      name: claims.name,
      given_name: claims.given_name,
      family_name: claims.family_name,
    }};
  }

  throw new Error("Could not resolve a profile endpoint and no id_token available.");
}

5) Nice-to-have: discover the API surface

If the backend is FastAPI/DRF/etc., these often exist:

GET https://citycatalyst.openearth.dev/api/v0/openapi.json

GET https://citycatalyst.openearth.dev/api/v0/docs
If you get HTML/Next.js again, you’re still hitting the UI; if you get JSON OpenAPI, you’ll see the exact me path.

6) About your earlier “Method Not Allowed”

That typically means wrong HTTP verb or path. For a profile endpoint it should be GET. If you POSTed there (or hit an auth-only UI route), you’ll see 405 or a UI page.

TL;DR

You exchanged the code correctly. The profile call is just pointed at the wrong route/host. Try GET /api/v0/users/me (with Authorization: Bearer ... and Accept: application/json). If no luck, decode the id_token and skip the profile call. Add a content-type guard so you never try to JSON.parse a Next.js HTML page again.