Based on the patterns in the codebase, here's what you'd need for a standalone API:

API Path
The API path would likely be:

GET /api/v0/user/cities
This follows the existing pattern in the codebase where user-related endpoints are under /api/v0/user/.

Required Data
Based on the enhanced boundary editor code I can see in app/src/app/[lng]/pocs/enhanced-boundary-editor/select-city/page.tsx, you would need:

Authentication Data
User ID from the OAuth token/session to identify which cities the user has access to
City Data Response
The API should return an array of cities with:

interface UserCity {
  cityId: string;
  name: string | null;
  country: string | null;
  region: string | null;
  locode: string | null;
  area: number | null;
  project?: {
    projectId: string;
    name: string | null;
  };
}
Database Query Logic
Based on the existing code patterns, the API would need to:

Get user's accessible cities via the CityUser relationship table
Include project information if needed for organizational context
Filter by LOCODE if you only want cities with boundaries available (like the regular boundary editor does)
Here's what the query logic would look like based on the existing patterns:

// Get cities through CityUser relationship
const cityUsers = await db.models.CityUser.findAll({
  where: {
    userId: session.user.id
  },
  include: [
    {
      model: db.models.City,
      as: "city",
      include: [
        {
          model: db.models.Project,
          as: "project"
        }
      ]
    }
  ]
});
const userCities = cityUsers.map(cityUser => cityUser.city);
Additional Considerations for Standalone App
Since you're building this as a standalone app with OAuth, you'd also need:

OAuth token validation middleware to verify the user's identity
Rate limiting for the API endpoints
Error handling for cases where the user has no cities or invalid tokens
CORS configuration if the frontend and backend are on different domains
The existing code shows this pattern works well - the enhanced boundary editor successfully fetches and displays user cities with project information, which is exactly what you'd want to replicate in the standalone API.