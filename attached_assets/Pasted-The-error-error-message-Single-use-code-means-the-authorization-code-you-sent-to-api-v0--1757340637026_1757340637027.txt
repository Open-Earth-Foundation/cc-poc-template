The error {"error":{"message":"Single-use code."}} means the authorization code you sent to /api/v0/token/ was already redeemed once. Per OAuth, an authorization code is single-use and must be rejected if reused. 
docs.authlib.org
 The CityCatalyst API uses standard OAuth2 + PKCE (auth at /authorize/, token at /api/v0/token/, PKCE required), so the fix is to make your callback flow idempotent and ensure you only hit the token endpoint once per code. 
GitHub

Here’s a tight checklist to fix it:

Make the callback route one-shot

As soon as you receive ?code=...&state=...:

Verify state.

Atomically mark the code (or its JWT jti) as “consumed” in a fast store (KV/Redis/memory with lock) before calling the token endpoint. If a second request arrives with the same code, short-circuit and redirect (don’t call /token/ again).

After a successful exchange, immediately 302 redirect to a clean page (no query params) and set Cache-Control: no-store to avoid the browser resubmitting the callback URL.

Guard against double handling in your stack

Don’t let two things handle the same callback. If you use NextAuth anywhere, avoid putting your custom callback under /api/auth/** (NextAuth reserves this path). Use something like /api/cc-oauth/callback and register that exact URL in the CityCatalyst OAuth client. (Docs list the dev endpoints and require PKCE. ) 
GitHub

In Next.js, do the token exchange on the server (API route) — not in client code — to avoid race conditions and React/Router prefetch quirks.

Store and clear the PKCE verifier correctly

Save code_verifier keyed by state when you send the user to /authorize/. On callback, look up by state, exchange the code once, and delete the stored verifier + state entry.

Match the exact redirect URI and environment

The redirect_uri in your token request must exactly match (character-for-character) what you used in the authorize request and what’s registered for the client.

Keep dev/prod consistent: use https://citycatalyst.openearth.dev/authorize/ and https://citycatalyst.openearth.dev/api/v0/token/ for dev (as in the wiki). 
GitHub

Add minimal logging/locks so you can see duplicates

Log state, and (optionally) the JWT jti from the code if CityCatalyst encodes one — use that as your de-dupe key.

Drop-in guard (TypeScript / Next.js API route)
// pseudo: put this in a module (so it persists) or use Redis/Upstash for true multi-instance safety
const consumed = new Set<string>(); // use Redis for production

function codeKey(codeJwt: string) {
  // If code is a JWT, prefer its `jti`; else hash the whole code
  try {
    const payload = JSON.parse(Buffer.from(codeJwt.split('.')[1], 'base64url').toString('utf8'));
    return payload?.jti || codeJwt;
  } catch { return codeJwt; }
}

export async function GET(req: Request) {
  const url = new URL(req.url);
  const code = url.searchParams.get('code');
  const state = url.searchParams.get('state');
  if (!code || !state) return new Response('Missing code/state', { status: 400 });

  const key = codeKey(code);
  if (consumed.has(key)) {
    // Already used: do NOT hit /token/ again
    return Response.redirect('/auth/done?status=already-used', 302);
  }
  consumed.add(key);

  // 1) lookup code_verifier by state (then delete it)
  // 2) POST grant_type=authorization_code + code + code_verifier + client_id + redirect_uri to:
  //    https://citycatalyst.openearth.dev/api/v0/token/
  // 3) store access token server-side (httpOnly cookie / session), then:
  return new Response(null, {
    status: 302,
    headers: {
      'Location': '/auth/done',
      'Cache-Control': 'no-store' // avoid replays
    }
  });
}

Common causes of this exact error (and how your logs map)

Double exchange (same callback processed twice — e.g., page reload, two handlers, or client + server both exchanging): server returns “Single-use code.” → exactly what you’re seeing. Fix with the one-shot guard above and a post-exchange redirect. 
docs.authlib.org

Another handler already used the code (e.g., NextAuth/provider misrouting): move your callback off /api/auth/* and register the new URI in the OAuth client. 
GitHub

If you implement the one-shot guard + unique callback path and keep the verifier/state lifecycle tight, CityCatalyst’s token endpoint will accept your first exchange and stop returning “Single-use code.”