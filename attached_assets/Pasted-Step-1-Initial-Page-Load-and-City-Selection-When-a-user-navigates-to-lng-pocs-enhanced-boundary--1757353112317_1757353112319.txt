Step 1: Initial Page Load and City Selection
When a user navigates to /[lng]/pocs/enhanced-boundary-editor/city/[cityId], the system:

Fetches city data from the database using the cityId parameter
Extracts key information needed for boundary search:
cityName (e.g., "Buenos Aires")
country (e.g., "Argentina")
locode (e.g., "ARBA1")
Step 2: Current Boundary Fetch
The EnhancedBoundaryViewer component first loads the existing boundary:

// Uses RTK Query to fetch current boundary from CityCatalyst database
const { data: currentBoundary } = api.useGetCityBoundaryQuery(locode!, {
  skip: !locode,
});
This calls /api/v0/cityboundary/city/${locode} which:

Queries the global API's OSM table for the stored boundary
Returns WKT geometry converted to GeoJSON
Provides area calculation and bounding box
Step 3: Alternative Boundaries Search
The system then searches for alternative boundaries using this flow:

API Call to Enhanced Boundaries Endpoint
const response = await fetch(`/api/v0/enhanced-boundaries?city=${encodeURIComponent(cityName)}&country=${encodeURIComponent(country)}`);
Overpass API Query Construction
The /api/v0/enhanced-boundaries route builds an Overpass query:

const query = `
  [out:json][timeout:60];
  area["ISO3166-1:alpha2"="${getCountryCode(country)}"]->.country;
  (
    rel(area.country)
      ["boundary"~"^(administrative|political)$"]
      ["name"~"^${escapeRegex(cityName)}$",i];
    way(area.country)
      ["boundary"~"^(administrative|political)$"]
      ["name"~"^${escapeRegex(cityName)}$",i];
  );
  out ids tags bb;
`;
This query:

Searches within the country's area
Looks for relations AND ways with boundary tags
Filters by administrative/political boundaries
Matches city name (case-insensitive)
Returns IDs, tags, and bounding boxes only (not full geometry yet)
Response Processing and Scoring
The API processes the Overpass response:

// Score each boundary based on various criteria
function scoreBoundary(boundary: OSMBoundary): number {
  let score = 0;
  
  // Administrative boundary preference
  if (boundary.tags.boundary === 'administrative') score += 10;
  
  // Admin level preference (6-10 are city-level)
  const adminLevel = parseInt(boundary.tags.admin_level || '0');
  if (adminLevel >= 6 && adminLevel <= 10) score += 5;
  
  // Name similarity bonus
  if (boundary.tags.name?.toLowerCase().includes(cityName.toLowerCase())) {
    score += 8;
  }
  
  return score;
}
Top 5 Selection
The system:

Scores all found boundaries
Sorts by score (highest first)
Takes the top 5 results
Returns them as GeoJSON features without full geometry
Step 4: Geometry Loading for Visualization
For each of the top 5 boundaries, the frontend makes individual requests to load full geometry:

const boundariesWithGeometry = await Promise.all(
  data.features.map(async (boundary: OSMBoundary): Promise<OSMBoundary> => {
    if (!boundary.geometry && boundary.properties?.osm_id) {
      try {
        const geomResponse = await fetch(`/api/v0/enhanced-boundaries/select`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            osm_id: boundary.properties.osm_id,
            type: 'preview' // Just get geometry for preview
          }),
        });
        
        if (geomResponse.ok) {
          const geomResult = await geomResponse.json();
          return {
            ...boundary,
            geometry: geomResult.geometry
          };
        }
      } catch (error) {
        console.error('Failed to load geometry for boundary', boundary.properties?.osm_id, error);
      }
    }
    return boundary;
  })
);
Detailed Geometry Fetch
The /api/v0/enhanced-boundaries/select endpoint:

// Constructs specific query for the boundary geometry
const query = `
  [out:json][timeout:20];
  ${boundary_type}(${osm_id});
  out geom;
`;
// Calls Overpass API
const response = await fetch(OVERPASS_URL, {
  method: "POST",
  body: new URLSearchParams({ data: query }),
  headers: {
    "Content-Type": "application/x-www-form-urlencoded",
  },
});
This returns the complete geometry coordinates for the specific boundary.

Step 5: Boundary Rendering
Grid Layout Rendering
The boundaries are displayed in a responsive grid:

<div className="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6 mb-6">
  {/* Current boundary card */}
  <div className="border rounded-lg overflow-hidden shadow-sm">
    <div className="h-48 bg-gray-100">
      <LeafletMap boundary={currentBoundary} />
    </div>
  </div>
  
  {/* Alternative boundaries */}
  {alternativeBoundaries.map((boundary, index) => (
    <div key={index} className="border rounded-lg overflow-hidden shadow-sm">
      <div className="h-48 bg-gray-100">
        <MiniMap boundary={boundary} onLoad={() => {}} />
      </div>
    </div>
  ))}
</div>
Mini Map Component
Each boundary gets its own mini Leaflet map:

const MiniMap: React.FC<MiniMapProps> = ({ boundary, onLoad }) => {
  const mapRef = useRef<L.Map | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    if (!containerRef.current || !boundary.geometry) return;
    // Initialize Leaflet map with disabled interactions
    const map = L.map(containerRef.current, {
      zoomControl: false,
      attributionControl: false,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
    });
    // Add OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    // Add boundary geometry as GeoJSON layer
    const geoJsonLayer = L.geoJSON(boundary.geometry, {
      style: {
        fillColor: '#3B82F6',
        weight: 2,
        opacity: 1,
        color: '#1D4ED8',
        dashArray: '3',
        fillOpacity: 0.3
      }
    }).addTo(map);
    // Auto-fit map to show entire boundary
    map.fitBounds(geoJsonLayer.getBounds(), { padding: [5, 5] });
    mapRef.current = map;
    onLoad();
    return () => {
      if (mapRef.current) {
        mapRef.current.remove();
      }
    };
  }, [boundary, onLoad]);
  return <div ref={containerRef} className="w-full h-full" />;
};
Step 6: Area Calculation and Metadata Display
For each boundary, the system calculates and displays metadata:

const calculateAreaFromGeometry = (geometry: any): number => {
  try {
    const feature = { type: "Feature", geometry };
    return area(feature) / 1000000; // Convert from sq meters to sq km
  } catch (error) {
    console.error('Error calculating area:', error);
    return 0;
  }
};
The metadata displayed includes:

Area: Calculated in square kilometers using the @turf/area library
OSM ID: The relation or way ID from OpenStreetMap
Name: The name tag from OSM data
Administrative Level: If available from OSM tags
Step 7: Boundary Selection and Download
When a user clicks "Choose Boundary":

const handleChooseBoundary = async (boundaryIndex: number): Promise<void> => {
  setDownloadingIndex(boundaryIndex);
  try {
    const boundary = alternativeBoundaries[boundaryIndex];
    const response = await fetch('/api/v0/enhanced-boundaries/select', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        osm_id: boundary.properties?.osm_id,
        boundary_type: 'relation'
      }),
    });
    if (response.ok) {
      const result = await response.json();
      
      // Create GeoJSON for download
      const geoJSON = {
        type: 'FeatureCollection',
        features: [
          {
            type: 'Feature',
            properties: {
              name: boundary.properties?.name || "Unnamed",
              osmId: boundary.properties?.osm_id,
              area: calculateAreaFromGeometry(result.geometry),
              downloadedAt: new Date().toISOString()
            },
            geometry: result.geometry
          }
        ]
      };
      // Trigger download
      const dataStr = JSON.stringify(geoJSON, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `${boundary.properties?.name || 'boundary'}-${boundary.properties?.osm_id}.geojson`;
      link.click();
      
      URL.revokeObjectURL(url);
    }
  } catch (error) {
    console.error('Error selecting boundary:', error);
  } finally {
    setDownloadingIndex(null);
  }
};
Key Technical Details
Error Handling
Overpass API timeouts: 60-second timeout for search, 20-second for geometry
Failed geometry loads: Individual boundaries that fail to load are shown without geometry
Network errors: Graceful fallbacks with error messages
Performance Optimizations
Lazy geometry loading: Only loads full geometry when needed for display
Concurrent requests: Uses Promise.all() to load multiple geometries in parallel
Mini-map optimizations: Disables all user interactions for better performance
OSM Data Processing
Relation vs Way handling: Supports both OSM relations and ways as boundaries
Country filtering: Uses ISO country codes to limit search scope
Name matching: Case-insensitive regex matching for city names
Administrative level filtering: Prioritizes admin_level 6-10 for city boundaries
This entire process ensures users get relevant, high-quality alternative boundaries from OpenStreetMap while maintaining good performance and user experience.