Short answer: yes—there are official endpoints for this. The flow is:

Get the user’s cities (you already do).

For each city (UN/LOCODE), call GET /api/v0/city/:city to fetch city info and the list of inventories (by year). 
GitHub Wiki Search

When you want the actual inventory, call GET /api/v0/city/:city/inventory/:year?format=json (JSON is also the default if format is omitted). 
GitHub Wiki Search

If you need the boundary map, call GET /api/v0/city/:city/boundary (GeoJSON). 
GitHub Wiki Search

Notes:

All API responses come wrapped in a { data: ... } envelope—read from res.data. 
GitHub Wiki Search

City is the UN/LOCODE, with spaces replaced by underscores (e.g., DE_BER). 
GitHub Wiki Search

Minimal TypeScript/Next code
const BASE = process.env.AUTH_BASE_URL ?? "https://citycatalyst.openearth.dev"; // or prod https://api.citycatalyst.io

type CitySummary = { locode: string; name?: string };
type CityDetail = {
  locode: string;
  name: string;
  inventories?: { year: number; id?: string }[]; // shape per backend
};

async function apiGet<T>(path: string, accessToken: string): Promise<T> {
  const url = `${BASE}${path}`;
  const res = await fetch(url, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "application/json",
    },
  });
  if (!res.ok) {
    const text = await res.text(); // helpful when you accidentally hit an HTML page
    throw new Error(`GET ${path} failed: ${res.status} ${res.statusText} — ${text.slice(0, 300)}`);
  }
  const json = await res.json();
  return (json.data ?? json) as T; // API wraps content under `data`
}

// 1) you already have this
async function getUserCities(accessToken: string): Promise<CitySummary[]> {
  return apiGet<CitySummary[]>(`/api/v0/user/cities/`, accessToken);
}

// 2) for each city, fetch inventories list (and years)
export async function getInventoriesByCity(accessToken: string) {
  const cities = await getUserCities(accessToken);

  const details = await Promise.all(
    cities.map(async (c) => {
      const locode = c.locode.replace(/\s+/g, "_"); // safety, per API docs
      const detail = await apiGet<CityDetail>(`/api/v0/city/${encodeURIComponent(locode)}`, accessToken);
      const years =
        (detail.inventories ?? [])
          .map((inv) => inv.year)
          .filter((y): y is number => Number.isFinite(y))
          .sort((a, b) => b - a);

      return { locode, name: detail.name, years, inventories: detail.inventories ?? [] };
    })
  );

  return details; // [{ locode, name, years: [2023, 2021, ...], inventories: [...] }, ...]
}

// 3) when you need the actual inventory JSON for a city-year
export async function getInventory(accessToken: string, locode: string, year: number) {
  const code = locode.replace(/\s+/g, "_");
  // `format=json` is optional; it’s the default
  return apiGet<any>(`/api/v0/city/${encodeURIComponent(code)}/inventory/${year}?format=json`, accessToken);
}

// 4) optional: boundary GeoJSON for a city
export async function getCityBoundary(accessToken: string, locode: string) {
  const code = locode.replace(/\s+/g, "_");
  return apiGet<GeoJSON.Feature>(`/api/v0/city/${encodeURIComponent(code)}/boundary`, accessToken);
}

Why this matches the docs

City summary with inventories: “GET /api/v0/city/:city returns the known info about the city and the list of inventories (for different years).” 
GitHub Wiki Search

Inventory JSON: “GET /api/v0/city/:city/inventory/:year?format=json returns the inventory… (also the default if no format is specified).” 
GitHub Wiki Search

Boundary: “GET /api/v0/city/:city/boundary returns the city boundary polygon as a GeoJSON shape.” 
GitHub Wiki Search

UN/LOCODE formatting: “:city is UN/LOCODE; spaces replaced with underscores.” 
GitHub Wiki Search

data envelope: “All endpoints return their response data in the data key …” 
GitHub Wiki Search

If you hit a big HTML blob instead of JSON, it’s almost always the wrong host/path (e.g., missing /api/v0/... and landing on the Next.js frontend). Keep the base URL to the backend (…openearth.dev or api.citycatalyst.io) and always include /api/v0/…, with Accept: application/json.