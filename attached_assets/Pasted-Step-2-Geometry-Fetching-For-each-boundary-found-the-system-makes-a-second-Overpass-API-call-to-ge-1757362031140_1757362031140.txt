Step 2: Geometry Fetching
For each boundary found, the system makes a second Overpass API call to get the actual polygon geometry:

// For each relation found, fetch its geometry
const geomQuery = `
[out:json][timeout:30];
(
  relation(${id});
  way(r);
  node(w);
);
out geom;
`;
const geomResponse = await fetch(OVERPASS_URL, {
  method: "POST",
  headers: { "Content-Type": "application/x-www-form-urlencoded" },
  body: new URLSearchParams({ data: geomQuery }),
});
Step 3: Converting OSM Data to GeoJSON
The raw OSM data is converted to GeoJSON using the osmtogeojson library:

import osmtogeojson from "osmtogeojson";
const rawOsmData = await geomResponse.json();
const geoJson = osmtogeojson(rawOsmData, { flatProperties: true });
// Find the specific relation in the converted data
const relationFeature = geoJson.features.find((f: any) => 
  f.id === `relation/${id}`
);
if (relationFeature?.geometry) {
  feature.geometry = relationFeature.geometry;
}
Step 4: Frontend Processing
When the frontend receives boundaries without geometry, it makes additional requests to /api/v0/enhanced-boundaries/select to fetch missing polygons:

// From EnhancedBoundaryViewer.tsx
const boundariesWithGeometry = await Promise.all(
  data.features.map(async (boundary: OSMBoundary) => {
    if (!boundary.geometry && boundary.properties?.osm_id) {
      const geomResponse = await fetch(`/api/v0/enhanced-boundaries/select`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          osm_id: boundary.properties.osm_id,
          type: 'preview'
        }),
      });
      
      if (geomResponse.ok) {
        const geomResult = await geomResponse.json();
        return { ...boundary, geometry: geomResult.geometry };
      }
    }
    return boundary;
  })
);
Key Technical Details
Overpass API Endpoints: The system uses https://overpass-api.de/api/interpreter

Two-Stage Process:

Search query gets boundary IDs and metadata
Geometry query gets the actual polygon coordinates
OSM Data Types:

Relations: Complex boundaries made up of multiple ways
Ways: Simple closed polygons
Data Format: Final polygons are in GeoJSON format for easy rendering in maps

The system handles both simple boundaries (ways) and complex multi-polygon boundaries (relations) that reference multiple ways and nodes to form complete city boundaries.