1. Backend API Route - Fetch Alternative Boundaries
First, create the main API endpoint that searches OpenStreetMap for alternative boundaries:

// api/enhanced-boundaries/route.ts
import { NextRequest, NextResponse } from "next/server";
import osmtogeojson from "osmtogeojson";
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const city = searchParams.get("city");
  const country = searchParams.get("country");
  if (!city || !country) {
    return NextResponse.json(
      { error: "City and country parameters are required" },
      { status: 400 }
    );
  }
  try {
    console.log(`Searching for boundaries: ${city}, ${country}`);
    // Step 1: Search for administrative boundaries
    const overpassQuery = `
      [out:json][timeout:60];
      area["ISO3166-1:alpha2"~"^${getCountryCode(country)}$"]->.country;
      (
        rel(area.country)["boundary"="administrative"]["name"~"${city}",i];
        way(area.country)["boundary"="administrative"]["name"~"${city}",i];
      );
      out ids tags bb;
    `;
    const response = await fetch(OVERPASS_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ data: overpassQuery }),
    });
    if (!response.ok) {
      throw new Error(`Overpass API error: ${response.statusText}`);
    }
    const osmData = await response.json();
    console.log(`Found ${osmData.elements?.length || 0} boundary elements`);
    if (!osmData.elements || osmData.elements.length === 0) {
      return NextResponse.json({
        city,
        country,
        features: []
      });
    }
    // Step 2: Convert to GeoJSON features and score them
    const features = osmData.elements.map((element: any) => ({
      type: "Feature",
      id: `${element.type}/${element.id}`,
      properties: {
        osm_id: element.id,
        name: element.tags?.name || "Unnamed",
        admin_level: element.tags?.admin_level,
        place: element.tags?.place,
        boundary: element.tags?.boundary,
        _area_deg2: calculateBoundingBoxArea(element.bbox),
      },
      _bounds: element.bbox ? {
        minlat: element.bbox.minlat,
        minlon: element.bbox.minlon,
        maxlat: element.bbox.maxlat,
        maxlon: element.bbox.maxlon,
      } : null,
      geometry: null // Will be loaded separately
    }));
    // Step 3: Score and rank boundaries
    const scoredFeatures = features
      .map(feature => ({
        ...feature,
        score: scoreFeature(feature, city)
      }))
      .sort((a, b) => b.score - a.score)
      .slice(0, 5); // Top 5 alternatives
    console.log(`Returning top ${scoredFeatures.length} boundaries`);
    return NextResponse.json({
      city,
      country,
      features: scoredFeatures
    });
  } catch (error) {
    console.error("Error fetching alternative boundaries:", error);
    return NextResponse.json(
      { error: "Failed to fetch alternative boundaries" },
      { status: 500 }
    );
  }
}
// Helper functions
function getCountryCode(country: string): string {
  const codes: Record<string, string> = {
    "Argentina": "AR",
    "Brazil": "BR",
    "United States": "US",
    // Add more as needed
  };
  return codes[country] || country;
}
function calculateBoundingBoxArea(bbox: any): number {
  if (!bbox) return 0;
  const { minlat, maxlat, minlon, maxlon } = bbox;
  return (maxlat - minlat) * (maxlon - minlon);
}
function scoreFeature(feature: any, searchTerm: string): number {
  let score = 0;
  const tags = feature.properties;
  // Administrative boundary preference
  if (tags.boundary === 'administrative') score += 10;
  // Admin level preference (6-10 are typically city-level)
  const adminLevel = parseInt(tags.admin_level || '0');
  if (adminLevel >= 6 && adminLevel <= 10) score += 5;
  // Area-based scoring (avoid too small/large boundaries)
  const area = tags._area_deg2 || 0;
  if (area > 0.001 && area < 1) score += 3;
  // Name similarity
  if (tags.name?.toLowerCase().includes(searchTerm.toLowerCase())) {
    score += 8;
  }
  return score;
}
2. Geometry Fetching API Route
Create an endpoint to fetch the actual polygon geometry for a selected boundary:

// api/enhanced-boundaries/select/route.ts
import { NextRequest, NextResponse } from "next/server";
import osmtogeojson from "osmtogeojson";
const OVERPASS_URL = "https://overpass-api.de/api/interpreter";
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { osm_id, type } = body;
    if (!osm_id) {
      return NextResponse.json(
        { error: "OSM ID is required" },
        { status: 400 }
      );
    }
    console.log(`Fetching geometry for OSM ID: ${osm_id}`);
    // Fetch detailed geometry from Overpass API
    const geomQuery = `
      [out:json][timeout:30];
      (
        relation(${osm_id});
        way(r);
        node(w);
      );
      out geom;
    `;
    const response = await fetch(OVERPASS_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({ data: geomQuery }),
    });
    if (!response.ok) {
      throw new Error(`Overpass API error: ${response.statusText}`);
    }
    const rawOsmData = await response.json();
    // Convert OSM data to GeoJSON
    const geoJson = osmtogeojson(rawOsmData, { flatProperties: true });
    // Find the specific relation in the converted data
    const relationFeature = geoJson.features.find((f: any) => 
      f.id === `relation/${osm_id}`
    );
    if (!relationFeature?.geometry) {
      return NextResponse.json(
        { error: "No geometry found for this boundary" },
        { status: 404 }
      );
    }
    // If this is a preview request, just return geometry
    if (type === 'preview') {
      return NextResponse.json({
        geometry: relationFeature.geometry
      });
    }
    // For full selection, return complete GeoJSON feature
    const completeFeature = {
      type: "FeatureCollection",
      features: [{
        type: "Feature",
        id: `relation/${osm_id}`,
        properties: relationFeature.properties,
        geometry: relationFeature.geometry
      }]
    };
    return NextResponse.json(completeFeature);
  } catch (error) {
    console.error("Error fetching boundary geometry:", error);
    return NextResponse.json(
      { error: "Failed to fetch boundary geometry" },
      { status: 500 }
    );
  }
}
